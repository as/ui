// MACHINE GENERATED BY 'go generate' COMMAND; DO NOT EDIT

package clip

import (
	"syscall"
	"unsafe"

	"golang.org/x/sys/windows"
)

var _ unsafe.Pointer

var (
	moduser32   = windows.NewLazySystemDLL("user32.dll")
	modkernel32 = windows.NewLazySystemDLL("kernel32.dll")

	procOpenClipboard    = moduser32.NewProc("OpenClipboard")
	procCloseClipboard   = moduser32.NewProc("CloseClipboard")
	procEmptyClipboard   = moduser32.NewProc("EmptyClipboard")
	procGetClipboardData = moduser32.NewProc("GetClipboardData")
	procSetClipboardData = moduser32.NewProc("SetClipboardData")
	procGlobalAlloc      = modkernel32.NewProc("GlobalAlloc")
	procGlobalLock       = modkernel32.NewProc("GlobalLock")
	procGlobalUnlock     = modkernel32.NewProc("GlobalUnlock")
	procGlobalFree       = modkernel32.NewProc("GlobalFree")
	procGlobalSize       = modkernel32.NewProc("GlobalSize")
)

func OpenClipboard(ha syscall.Handle) (err error) {
	r1, _, e1 := syscall.Syscall(procOpenClipboard.Addr(), 1, uintptr(ha), 0, 0)
	if r1 == 0 {
		if e1 != 0 {
			err = error(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func CloseClipboard() (err error) {
	r1, _, e1 := syscall.Syscall(procCloseClipboard.Addr(), 0, 0, 0, 0)
	if r1 == 0 {
		if e1 != 0 {
			err = error(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func EmptyClipboard() (err error) {
	r1, _, e1 := syscall.Syscall(procEmptyClipboard.Addr(), 0, 0, 0, 0)
	if r1 == 0 {
		if e1 != 0 {
			err = error(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func GetClipboardData(fmt int) (ha syscall.Handle, err error) {
	r0, _, e1 := syscall.Syscall(procGetClipboardData.Addr(), 1, uintptr(fmt), 0, 0)
	ha = syscall.Handle(r0)
	if ha == 0 {
		if e1 != 0 {
			err = error(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func SetClipboardData(fmt int, ha syscall.Handle) (err error) {
	r1, _, e1 := syscall.Syscall(procSetClipboardData.Addr(), 2, uintptr(fmt), uintptr(ha), 0)
	if r1 == 0 {
		if e1 != 0 {
			err = error(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func GlobalAlloc(flag int, size int) (gh syscall.Handle, err error) {
	r0, _, e1 := syscall.Syscall(procGlobalAlloc.Addr(), 2, uintptr(flag), uintptr(size), 0)
	gh = syscall.Handle(r0)
	if gh == 0 {
		if e1 != 0 {
			err = error(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func GlobalLock(gh syscall.Handle) (h syscall.Handle, err error) {
	r0, _, e1 := syscall.Syscall(procGlobalLock.Addr(), 1, uintptr(gh), 0, 0)
	h = syscall.Handle(r0)
	if h == 0 {
		if e1 != 0 {
			err = error(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func GlobalUnlock(gh syscall.Handle) (err error) {
	r1, _, e1 := syscall.Syscall(procGlobalUnlock.Addr(), 1, uintptr(gh), 0, 0)
	if r1 == uintptr(syscall.InvalidHandle) {
		if e1 != 0 {
			err = error(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func GlobalFree(gh syscall.Handle) (err error) {
	r1, _, e1 := syscall.Syscall(procGlobalFree.Addr(), 1, uintptr(gh), 0, 0)
	if r1 == 0 {
		if e1 != 0 {
			err = error(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}

func GlobalSize(gh syscall.Handle) (size int, err error) {
	r0, _, e1 := syscall.Syscall(procGlobalSize.Addr(), 1, uintptr(gh), 0, 0)
	size = int(r0)
	if size == 0 {
		if e1 != 0 {
			err = error(e1)
		} else {
			err = syscall.EINVAL
		}
	}
	return
}
